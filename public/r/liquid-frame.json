{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "liquid-frame",
  "type": "registry:block",
  "title": "Liquid-frame Component",
  "description": "Liquid Frame adds a fluid, interactive water ripple effect to images.",
  "dependencies": [
    "three"
  ],
  "devDependencies": [
    "@types/three"
  ],
  "files": [
    {
      "path": "src/registry/default/liquid-frame/components/liquid-frame.tsx",
      "content": "'use client';\r\n\r\nimport React, { useEffect, useRef, useState } from 'react';\r\nimport * as THREE from 'three';\r\nimport Image from 'next/image';\r\nimport {\r\n  simulationVertexShader,\r\n  simulationFragmentShader,\r\n  renderVertexShader,\r\n  renderFragmentShader,\r\n} from '@/lib/liquid-frame';\r\n\r\n// Define shader types (assuming shaders are strings)\r\ntype ShaderSource = string;\r\n\r\n// Ensure shader imports are treated as strings\r\ninterface ShaderImports {\r\n  simulationVertexShader: ShaderSource;\r\n  simulationFragmentShader: ShaderSource;\r\n  renderVertexShader: ShaderSource;\r\n  renderFragmentShader: ShaderSource;\r\n}\r\n\r\ninterface LiquidFrameProps {\r\n  src: string;\r\n  alt?: string;\r\n  width?: number;\r\n  height?: number;\r\n  className?: string;\r\n}\r\n\r\ninterface DimensionsProps {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport default function LiquidFrame({\r\n  src,\r\n  alt = 'Image with water effect',\r\n  width = 500,\r\n  height = 300,\r\n  className = '',\r\n}: LiquidFrameProps) {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const [dimensions, setDimensions] = useState<DimensionsProps>({ width, height });\r\n\r\n  useEffect(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const container = containerRef.current;\r\n\r\n    // Load image to get natural dimensions\r\n    const img = new window.Image();\r\n    img.src = src;\r\n    img.onload = () => {\r\n      const aspectRatio = img.naturalWidth / img.naturalHeight;\r\n      const containerWidth = container.clientWidth;\r\n      const containerHeight = container.clientHeight;\r\n\r\n      // Calculate dimensions to cover the container while maintaining aspect ratio\r\n      let newWidth = containerWidth;\r\n      let newHeight = containerWidth / aspectRatio;\r\n\r\n      // If calculated height is less than container height, adjust to cover height\r\n      if (newHeight < containerHeight) {\r\n        newHeight = containerHeight;\r\n        newWidth = containerHeight * aspectRatio;\r\n      }\r\n\r\n      // Update dimensions\r\n      setDimensions({\r\n        width: newWidth,\r\n        height: newHeight,\r\n      });\r\n\r\n      // Setup Three.js\r\n      const scene = new THREE.Scene();\r\n      const simScene = new THREE.Scene();\r\n      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\r\n\r\n      const renderer = new THREE.WebGLRenderer({\r\n        antialias: true,\r\n        alpha: true,\r\n        preserveDrawingBuffer: true,\r\n      });\r\n\r\n      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n      renderer.setSize(newWidth, newHeight);\r\n      container.appendChild(renderer.domElement);\r\n\r\n      // Initialize variables\r\n      const mouse = new THREE.Vector2();\r\n      let frame = 0;\r\n\r\n      const canvasWidth = newWidth * window.devicePixelRatio;\r\n      const canvasHeight = newHeight * window.devicePixelRatio;\r\n\r\n      const options: THREE.RenderTargetOptions = {\r\n        format: THREE.RGBAFormat,\r\n        type: THREE.FloatType,\r\n        minFilter: THREE.LinearFilter,\r\n        magFilter: THREE.LinearFilter,\r\n        stencilBuffer: false,\r\n        depthBuffer: false,\r\n      };\r\n\r\n      let rtA = new THREE.WebGLRenderTarget(canvasWidth, canvasHeight, options);\r\n      let rtB = new THREE.WebGLRenderTarget(canvasWidth, canvasHeight, options);\r\n\r\n      // Create simulation material\r\n      const simMaterial = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n          textureA: { value: null as THREE.Texture | null },\r\n          mouse: { value: mouse },\r\n          resolution: { value: new THREE.Vector2(canvasWidth, canvasHeight) },\r\n          time: { value: 0 },\r\n          frame: { value: 0 },\r\n        },\r\n        vertexShader: simulationVertexShader as ShaderSource,\r\n        fragmentShader: simulationFragmentShader as ShaderSource,\r\n      });\r\n\r\n      // Load the specified image\r\n      const textureLoader = new THREE.TextureLoader();\r\n      const imageTexture = textureLoader.load(src);\r\n\r\n      imageTexture.minFilter = THREE.LinearFilter;\r\n      imageTexture.magFilter = THREE.LinearFilter;\r\n      imageTexture.format = THREE.RGBAFormat;\r\n\r\n      // Create render material\r\n      const renderMaterial = new THREE.ShaderMaterial({\r\n        uniforms: {\r\n          textureA: { value: null as THREE.Texture | null },\r\n          textureB: { value: imageTexture },\r\n        },\r\n        vertexShader: renderVertexShader as ShaderSource,\r\n        fragmentShader: renderFragmentShader as ShaderSource,\r\n        transparent: true,\r\n      });\r\n\r\n      // Create quads\r\n      const plane = new THREE.PlaneGeometry(2, 2);\r\n      const simQuad = new THREE.Mesh(plane, simMaterial);\r\n      const renderQuad = new THREE.Mesh(plane, renderMaterial);\r\n      simScene.add(simQuad);\r\n      scene.add(renderQuad);\r\n\r\n      // Handle resize\r\n      const handleResize = () => {\r\n        if (!containerRef.current) return;\r\n\r\n        const newRect = containerRef.current.getBoundingClientRect();\r\n        let newWidth = newRect.width;\r\n        let newHeight = newWidth / aspectRatio;\r\n\r\n        // If container height is smaller, adjust to fit height\r\n        if (newHeight > newRect.height) {\r\n          newHeight = newRect.height;\r\n          newWidth = newHeight * aspectRatio;\r\n        }\r\n\r\n        // Update dimensions for the component\r\n        setDimensions({\r\n          width: newWidth,\r\n          height: newHeight,\r\n        });\r\n\r\n        // Update Three.js renderer and materials\r\n        const canvasWidth = newWidth * window.devicePixelRatio;\r\n        const canvasHeight = newHeight * window.devicePixelRatio;\r\n\r\n        renderer.setSize(newWidth, newHeight);\r\n        rtA.setSize(canvasWidth, canvasHeight);\r\n        rtB.setSize(canvasWidth, canvasHeight);\r\n        simMaterial.uniforms.resolution.value.set(canvasWidth, canvasHeight);\r\n      };\r\n\r\n      window.addEventListener('resize', handleResize);\r\n\r\n      // Handle mouse movement relative to container\r\n      const handleMouseMove = (e: MouseEvent) => {\r\n        if (!containerRef.current) return;\r\n\r\n        const rect = containerRef.current.getBoundingClientRect();\r\n        const x = e.clientX - rect.left;\r\n        const y = rect.height - (e.clientY - rect.top);\r\n\r\n        // Only update if mouse is inside the container\r\n        if (x >= 0 && x <= rect.width && y >= 0 && y <= rect.height) {\r\n          mouse.x = x * window.devicePixelRatio;\r\n          mouse.y = y * window.devicePixelRatio;\r\n        } else {\r\n          mouse.set(0, 0);\r\n        }\r\n      };\r\n\r\n      // Handle mouse leave\r\n      const handleMouseLeave = () => {\r\n        mouse.set(0, 0);\r\n      };\r\n\r\n      container.addEventListener('mousemove', handleMouseMove);\r\n      container.addEventListener('mouseleave', handleMouseLeave);\r\n\r\n      // Animation loop\r\n      const animate = () => {\r\n        simMaterial.uniforms.frame.value = frame++;\r\n        simMaterial.uniforms.time.value = performance.now() / 1000;\r\n\r\n        simMaterial.uniforms.textureA.value = rtA.texture;\r\n        renderer.setRenderTarget(rtB);\r\n        renderer.render(simScene, camera);\r\n\r\n        renderMaterial.uniforms.textureA.value = rtB.texture;\r\n        renderer.setRenderTarget(null);\r\n        renderer.render(scene, camera);\r\n\r\n        const temp = rtA;\r\n        rtA = rtB;\r\n        rtB = temp;\r\n\r\n        requestAnimationFrame(animate);\r\n      };\r\n\r\n      animate();\r\n\r\n      // Cleanup\r\n      return () => {\r\n        window.removeEventListener('resize', handleResize);\r\n        container.removeEventListener('mousemove', handleMouseMove);\r\n        container.removeEventListener('mouseleave', handleMouseLeave);\r\n\r\n        renderer.dispose();\r\n        rtA.dispose();\r\n        rtB.dispose();\r\n        simMaterial.dispose();\r\n        renderMaterial.dispose();\r\n        plane.dispose();\r\n\r\n        if (container.contains(renderer.domElement)) {\r\n          container.removeChild(renderer.domElement);\r\n        }\r\n      };\r\n    };\r\n\r\n    // Handle image load error\r\n    img.onerror = () => {\r\n      console.error('Failed to load image:', src);\r\n      setDimensions({ width, height }); // Fallback to default dimensions\r\n    };\r\n\r\n  }, [src, width, height]);\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`relative w-full h-full ${className}`}\r\n      style={{\r\n        width: '100%',\r\n        height: '100%',\r\n        overflow: 'hidden',\r\n      }}\r\n    >\r\n      {/* Hidden base image for proper sizing */}\r\n      <div style={{ visibility: 'hidden', position: 'absolute', width: '100%', height: '100%' }}>\r\n        <Image\r\n          src={src}\r\n          alt={alt}\r\n          fill\r\n          style={{ objectFit: 'cover' }}\r\n        />\r\n      </div>\r\n    </div>\r\n  );\r\n}",
      "type": "registry:component",
      "target": "src/components/liquid-frame.tsx"
    },
    {
      "path": "src/registry/default/liquid-frame/lib/liquid-frame.ts",
      "content": "export const simulationVertexShader = `\r\n  varying vec2 vUv;\r\n  void main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  }\r\n`;\r\n\r\nexport const simulationFragmentShader = `\r\n  uniform sampler2D textureA;\r\n  uniform vec2 mouse;\r\n  uniform vec2 resolution;\r\n  uniform float time;\r\n  uniform int frame;\r\n  varying vec2 vUv;\r\n  \r\n  const float delta = 1.4;\r\n\r\n  void main() {\r\n    vec2 uv = vUv;\r\n    if (frame == 0) {\r\n      gl_FragColor = vec4(0.0);\r\n      return;\r\n    }\r\n\r\n    vec4 data = texture2D(textureA, uv);\r\n    float pressure = data.x;\r\n    float pVel = data.y;\r\n    \r\n    vec2 texelSize = 1.0 / resolution;\r\n    float p_right = texture2D(textureA, uv + vec2(texelSize.x, 0.0)).x;\r\n    float p_left = texture2D(textureA, uv + vec2(-texelSize.x, 0.0)).x;\r\n    float p_up = texture2D(textureA, uv + vec2(0.0, texelSize.y)).x;\r\n    float p_down = texture2D(textureA, uv + vec2(0.0, -texelSize.y)).x;\r\n\r\n    if (uv.x <= texelSize.x) p_left = p_right;\r\n    if (uv.x >= 1.0 - texelSize.x) p_right = p_left;\r\n    if (uv.y <= texelSize.y) p_down = p_up;\r\n    if (uv.y >= 1.0 - texelSize.y) p_up = p_down;\r\n\r\n    // Enhanced wave equation matching ShaderToy\r\n    pVel += delta * (-2.0 * pressure + p_right + p_left) / 4.0;\r\n    pVel += delta * (-2.0 * pressure + p_up + p_down) / 4.0;\r\n\r\n    pressure += delta * pVel;\r\n    pVel -= 0.005 * delta * pressure;    \r\n    \r\n    pVel *= 1.0 - 0.002 * delta;\r\n\r\n    // changed pressure\r\n    pressure *= 0.95;\r\n\r\n    vec2 mouseUV = mouse / resolution;\r\n    if (mouse.x > 0.0) {\r\n      float dist = distance(uv, mouseUV);\r\n\r\n    // changed pressure & radius\r\n      if (dist <= 0.02) { // Smaller radius for more precise ripples\r\n        pressure += 1.5 * (1.0 - dist / 0.02); // Increased intensity\r\n      }\r\n    }\r\n\r\n    gl_FragColor = vec4(pressure, pVel, (p_right - p_left) / 2.0, (p_up - p_down) / 2.0);\r\n  }\r\n`;\r\n\r\nexport const renderVertexShader = `\r\n  varying vec2 vUv;\r\n  void main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  }\r\n`;\r\n\r\nexport const renderFragmentShader = `\r\n  uniform sampler2D textureA;\r\n  uniform sampler2D textureB;\r\n  varying vec2 vUv;\r\n\r\n  void main() {\r\n    vec4 data = texture2D(textureA, vUv);\r\n    vec2 distortion = 0.3 * data.zw;\r\n    vec4 color = texture2D(textureB, vUv + distortion);\r\n\r\n    vec3 normal = normalize(vec3(-data.z * 2.0, 0.5, -data.w * 2.0));\r\n    vec3 lightDir = normalize(vec3(-3.0, 5.0, 3.0));\r\n    float specular = pow(max(0.0, dot(normal, lightDir)), 60.0) * 1.5;\r\n\r\n    gl_FragColor = color + vec4(specular);\r\n  }\r\n`;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// ",
      "type": "registry:lib",
      "target": "src/lib/liquid-frame.ts"
    }
  ]
}